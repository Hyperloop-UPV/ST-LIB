/*
 * TimerWrapper.hpp
 *
 *  Created on: 30 dic. 2025
 *      Author: victor
 */

#pragma once

#ifdef HAL_TIM_MODULE_ENABLED

#include "HALAL/Models/TimerDomain/TimerDomain.hpp"
#include "HALAL/Services/PWM/PWM/NewPWM.hpp"
#include "HALAL/Models/GPIO.hpp"

#include "ErrorHandler/ErrorHandler.hpp"

#include "stm32h7xx_hal.h"

#define get_timer_instance(board, timer_type) \
    ST_LIB::TimerWrapper<timer_type>(board::instance_of<timer_type>())

namespace ST_LIB {

template<const TimerDomain::Timer &dev>
struct TimerWrapper {
    TimerDomain::Instance& instance;
    TimerWrapper(TimerDomain::Instance& inst) : instance(inst) {}

    static constexpr bool bits32timer = (
        dev.e.request == TimerRequest::GeneralPurpose32bit_2 ||
        dev.e.request == TimerRequest::GeneralPurpose32bit_3 ||
        dev.e.request == TimerRequest::GeneralPurpose32bit_23 ||
        dev.e.request == TimerRequest::GeneralPurpose32bit_24 ||
        dev.e.request == TimerRequest::Any32bit
    );

    template<TimerPin pin>
    inline PWM<dev> get_pwm(uint8_t channel) {
        static_assert(dev.e.pin_count > 0, "Need at least one pin to get a pwm");
        if constexpr(dev.e.pins[0].pin == pin.pin) {
            static_assert(dev.e.pins[0].af == TimerAF::PWM, "Pin must be configured in TimerWrapper as a PWM");
            return PWM<dev>(this, pin);
        }

        static_assert(dev.e.pin_count > 1, "No pins passed to TimerWrapper are the same as the pins passed to get_pwm() [this method]");
        if constexpr(dev.e.pins[1].pin == pin.pin) {
            static_assert(dev.e.pins[1].af == TimerAF::PWM, "Pin must be configured in TimerWrapper as a PWM");
            return PWM<dev>(this, pin);
        }

        static_assert(dev.e.pin_count > 2, "No pins passed to TimerWrapper are the same as the pins passed to get_pwm() [this method]");
        if constexpr(dev.e.pins[2].pin == pin.pin) {
            static_assert(dev.e.pins[2].af == TimerAF::PWM, "Pin must be configured in TimerWrapper as a PWM");
            return PWM<dev>(this, pin);
        }

        static_assert(dev.e.pin_count == 4, "No pins passed to TimerWrapper are the same as the pins passed to get_pwm() [this method]");
        if constexpr(dev.e.pins[3].pin == pin.pin) {
            static_assert(dev.e.pins[3].af == TimerAF::PWM, "Pin must be configured in TimerWrapper as a PWM");
            return PWM<dev>(this, pin);
        }
    }

    inline void counter_enable() {
        SET_BIT(instance.tim->CR1, TIM_CR1_CEN);
    }
    inline void counter_disable() {
        CLEAR_BIT(instance.tim->CR1, TIM_CR1_CEN);
    }

    inline void clear_update_interrupt_flag() {
        CLEAR_BIT(instance.tim->SR, TIM_SR_UIF);
    }

    /* Disabled by default */
    inline void enable_update_interrupt() {
        SET_BIT(instance.tim->DIER, TIM_DIER_UIE);
    }
    inline void disable_update_interrupt() {
        CLEAR_BIT(instance.tim->DIER, TIM_DIER_UIE);
    }

    /* Disabled by default */
    inline void enable_nvic() {
        NVIC_EnableIRQ(TimerDomain::timer_irqn[instance.timer_idx]);
    }
    inline void disable_nvic() {
        NVIC_DisableIRQ(TimerDomain::timer_irqn[instance.timer_idx]);
    }

    /* Enable UEV. The Update (UEV) event is generated by one of the following events:
     * – Counter overflow/underflow
     * – Setting the UG bit
     * – Update generation through the slave mode controller    
     * Enabled by default
     */
    inline void enable_update_event() {
        CLEAR_BIT(instance.tim->CR1, TIM_CR1_UDIS);
    }
    /* Disable UEV. The Update event is not generated, shadow registers keep their value
     * (ARR, PSC, CCRx). However the counter and the prescaler are reinitialized if the UG bit
     * is set or if a hardware reset is received from the slave mode controller.
     */
    inline void disable_update_event() {
        SET_BIT(instance.tim->CR1, TIM_CR1_UDIS);
    }

    /* default: disabled */
    inline void break_interrupt_enable() {
        static_assert(dev.e.request == TimerRequest::Advanced_1 || dev.e.request == TimerRequest::Advanced_8,
            "Error: Break interrupt enable only allowed in advanced timers {TIM1, TIM8}");
        ErrorHandler("Break interrupt is not allowed currently because gp timers {TIM12, TIM13, TIM14} use the same interrupt callback");
    }
    inline void break_interrupt_disable() {
        static_assert(dev.e.request == TimerRequest::Advanced_1 || dev.e.request == TimerRequest::Advanced_8,
            "Error: Break interrupt enable only allowed in advanced timers {TIM1, TIM8}");
        SET_BIT(instance.tim->DIER, TIM_DIER_BIE);
    }

    /* interrupt gets called only once, counter needs to be reenabled */
    inline void set_one_pulse_mode() {
        SET_BIT(instance.tim->CR1, TIM_CR1_OPM);
    }
    inline void multi_interrupt() {
        CLEAR_BIT(instance.tim->CR1, TIM_CR1_OPM);
    }

    inline TIM_HandleTypeDef *get_hal_handle() {
        return instance.hal_tim;
    }
    inline TIM_TypeDef *get_cmsis_handle() {
        return instance.tim;
    }

    template<uint16_t psc = 0>
    inline void configure32bit(void (*callback)(void*), void *callback_data, uint32_t period)
    {
        static_assert(bits32timer, "Only timers {TIM2, TIM5, TIM23, TIM24} have a 32-bit resolution");

        if constexpr (psc != 0) {
            instance.tim->PSC = psc;
        }
        instance.tim->ARR = period;
        TimerDomain::callbacks[instance.timer_idx] = callback;
        TimerDomain::callback_data[instance.timer_idx] = callback_data;
        this->counter_enable();
    }

    template<uint16_t psc = 0>
    inline void configure16bit(void (*callback)(void*), void *callback_data, uint16_t period)
    {
        if constexpr (psc != 0) {
            instance.tim->PSC = psc;
        }
        instance.tim->ARR = period;
        TimerDomain::callbacks[instance.timer_idx] = callback;
        TimerDomain::callback_data[instance.timer_idx] = callback_data;
        this->counter_enable();
    }

    // leftover from old TimerPeripheral, maybe this was useful?
    inline uint16_t get_prescaler() {
        return instance.tim->PSC;
    }
    inline uint32_t get_period() {
        return instance.tim->ARR;
    }

#if 0
    if constexpr (dev.e.request == TimerRequest::Advanced_1 || dev.e.request == TimerRequest::Advanced_8) {
        // advanced specific functions
    }

    if constexpr (dev.e.request != TimerRequest::Basic_6 && dev.e.request != TimerRequest::Basic_7) {
        // general purpose and advanced functions
    }
#endif

    /* WARNING: The counter _must_ be disabled to switch from edge-aligned to center-aligned mode */
    template<TimerDomain::CountingMode mode>
    inline void set_mode(void) {
        constexpr uint8_t reqint = static_cast<uint8_t>(dev.e.request);
        static_assert(!(reqint == 1 || reqint == 8 ||
                reqint == 2 || reqint == 5 || reqint == 23 || reqint == 24 || 
                reqint == 3 || reqint == 4),
            "Error: In request reqidx: Timers other than {Advanced{TIM1, TIM8}, TIM2, TIM3, TIM4, TIM5, TIM23, TIM24} only support upcounting");

        if constexpr (mode == TimerDomain::CountingMode::UP) {
            MODIFY_REG(instance.tim->CR1, TIM_CR1_CMS, 0);
            CLEAR_BIT(instance.tim->CR1, TIM_CR1_DIR); // upcounter
        } else if constexpr (mode == TimerDomain::CountingMode::DOWN) {
            MODIFY_REG(instance.tim->CR1, TIM_CR1_CMS, 0);
            SET_BIT(instance.tim->CR1, TIM_CR1_DIR); // downcounter
        } else if constexpr (mode == TimerDomain::CountingMode::CENTER_ALIGNED_INTERRUPT_DOWN) {
            MODIFY_REG(instance.tim->CR1, TIM_CR1_CMS, TIM_CR1_CMS_0);
        } else if constexpr (mode == TimerDomain::CountingMode::CENTER_ALIGNED_INTERRUPT_UP) {
            MODIFY_REG(instance.tim->CR1, TIM_CR1_CMS, TIM_CR1_CMS_1);
        } else if constexpr (mode == TimerDomain::CountingMode::CENTER_ALIGNED_INTERRUPT_BOTH) {
            MODIFY_REG(instance.tim->CR1, TIM_CR1_CMS, (TIM_CR1_CMS_0 | TIM_CR1_CMS_1));
        }
    }
};
} // namespace ST_LIB

#endif // HAL_TIM_MODULE_ENABLED
