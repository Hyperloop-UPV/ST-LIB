#!/usr/bin/env bash
set -euo pipefail

REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$REPO_ROOT"

if [[ ! -e ".git" ]]; then
    echo "This script must run inside a git repository."
    exit 1
fi

if ! command -v pre-commit >/dev/null 2>&1; then
    echo "pre-commit is not installed."
    echo "Install with: pip install pre-commit"
    exit 1
fi

pre-commit install -f --install-hooks --hook-type pre-commit --hook-type pre-push

HOOK_DIR="$(git rev-parse --git-path hooks)"
PRE_COMMIT_HOOK="$HOOK_DIR/pre-commit"
GENERATED_PRE_COMMIT_HOOK="$HOOK_DIR/pre-commit.pre-commit-generated"
LEGACY_PRE_COMMIT_HOOK="$HOOK_DIR/pre-commit.legacy"

if [[ ! -f "$PRE_COMMIT_HOOK" ]]; then
    echo "Expected pre-commit hook at $PRE_COMMIT_HOOK, but it was not created."
    exit 1
fi

# Keep the hook generated by pre-commit and place a wrapper in front of it.
cp "$PRE_COMMIT_HOOK" "$GENERATED_PRE_COMMIT_HOOK"
rm -f "$LEGACY_PRE_COMMIT_HOOK"

cat > "$PRE_COMMIT_HOOK" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

HOOK_DIR="$(cd "$(dirname "$0")" && pwd)"
BASE_HOOK="$HOOK_DIR/pre-commit.pre-commit-generated"

if [[ ! -x "$BASE_HOOK" ]]; then
    echo "Missing generated pre-commit hook: $BASE_HOOK" >&2
    exit 1
fi

staged_files=()
while IFS= read -r -d '' file; do
    staged_files+=("$file")
done < <(git diff --cached --name-only --diff-filter=ACMR -z)

# First pass: run normal pre-commit checks/fixers.
if "$BASE_HOOK" "$@"; then
    exit 0
fi

# Auto-stage only files that were already staged before the hook ran.
if [[ ${#staged_files[@]} -gt 0 ]]; then
    git add --update -- "${staged_files[@]}"
fi

# Second pass: if it still fails, abort commit.
"$BASE_HOOK" "$@"
EOF

chmod +x "$PRE_COMMIT_HOOK" "$GENERATED_PRE_COMMIT_HOOK"

echo "Hooks installed (pre-commit and pre-push)."
echo "pre-commit wrapper enabled with auto-restage on formatter changes."
